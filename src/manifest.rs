use nom::{
    bytes::complete::tag,
    character::complete::{space0, u32 as parse_u32},
    combinator::eof,
    sequence::{delimited, pair},
};
use serde_json::json;
use std::io::{stdin, stdout, Result as IoResult, Stdin, Stdout, Write};
use uuid::Uuid;

use nom::sequence::tuple;

pub struct McManifest {
    pub name: String,
    pub description: String,
    pub version: [u32; 3],
    pub min_engine_version: [u32; 3],
    pub header_uuid: Uuid,
    pub module_uuid: Uuid,
}

struct Interacter {
    stdin: Stdin,
    stdout: Stdout,
    buffer: String,
}

impl Interacter {
    fn new() -> Self {
        Self {
            stdin: stdin(),
            stdout: stdout(),
            buffer: String::new(),
        }
    }

    fn read_line(&mut self, prompt: &str, default: &str) -> IoResult<String> {
        self.read_line_raw(prompt, default)?;
        Ok(std::mem::take(&mut self.buffer))
    }

    fn read_line_raw(&mut self, prompt: &str, default: &str) -> IoResult<()> {
        print!("{prompt}({default})：");
        self.stdout.flush()?;
        self.stdin.read_line(&mut self.buffer)?;
        trim_in_place(&mut self.buffer);
        if self.buffer.is_empty() {
            self.buffer.push_str(default);
        }
        Ok(())
    }

    fn read_version(&mut self, prompt: &str, default: &str) -> IoResult<[u32; 3]> {
        loop {
            self.read_line_raw(prompt, default)?;
            let Some(version) = parse_version(&self.buffer) else {
                println!("版本号格式错误，请参考或直接使用默认版本号");
                self.buffer.clear();
                continue;
            };
            self.buffer.clear();
            break Ok(version);
        }
    }
}

fn parse_version(s: &str) -> Option<[u32; 3]> {
    let nom::IResult::<&str, _>::Ok((_, (a, _, b, _, c))) = delimited(
        space0,
        tuple((parse_u32, tag("."), parse_u32, tag("."), parse_u32)),
        pair(space0, eof),
    )(s) else {
        return None;
    };
    Some([a, b, c])
}

impl McManifest {
    pub fn interact() -> IoResult<Self> {
        println!("正在进行交互式生成manifest.json...");
        let time = chrono::Local::now();
        let mut interacter = Interacter::new();
        let name = interacter.read_line("行为包名称", "MCSH Test")?;
        let description = interacter.read_line(
            "行为包描述",
            &format!("Generated by MCSH Compiler at {}", time.format("%F %T")),
        )?;
        let version = interacter.read_version("行为包版本", "1.0.0")?;
        let min_engine_version = interacter.read_version("最小游戏版本", "1.20.0")?;

        Ok(Self {
            name,
            description,
            version,
            min_engine_version,
            header_uuid: Uuid::new_v4(),
            module_uuid: Uuid::new_v4(),
        })
    }

    pub fn to_json(&self) -> String {
        let Self {
            name,
            description,
            version,
            min_engine_version,
            header_uuid,
            module_uuid,
        } = self;
        let json = json! {{
            "format_version": 2,
            "header": {
                "description": description,
                "name": name,
                "uuid": header_uuid,
                "version": version,
                "min_engine_version": min_engine_version,
            },
            "modules": [
                {
                    "description": description,
                    "type": "data",
                    "uuid": module_uuid,
                    "version": version
                }
            ]
        }};
        format!("{json:#}")
    }
}

fn trim_in_place(s: &mut String) {
    s.truncate(s.trim_end().len());
    s.drain(..s.len() - s.trim_start().len());
}
